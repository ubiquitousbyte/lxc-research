\chapter{Implementation}
This chapter focuses on the implementation details of the container runtime 
and the benchmark tool. 

Section \ref{ch:implementation/runtime} dives deeply into the 
system call interface of the Linux kernel that enables the creation and execution 
of isolated workloads. This chapter also contains a qualitative evaluation of the runtime's 
security characteristics. 

\label{ch:implementation}
\section{Runtime}
\label{ch:implementation/runtime}
The \verb|clone()| system call is the runtime's primary method of isolating a process.
This system call creates a new execution context and allows the caller to configure it 
through a bit mask. In essence, this bit mask defines the noninterference boundary between 
the new execution context, its parent, and all other processes on the system. If the bit mask is 0, 
the clone system call is equivalent to a simple \verb|fork()|. The runtime utilises this 
system call for two purposes - to spawn the container process in a new set of namespaces and to 
create a pollable process file descriptor for it. 
Achieving the former is trivial. The kernel exposes a flag for every namespace type.
These flags are simply ORed together and passed into the system call. 
Internally, the kernel allocates a new namespace proxy and all of its namespaces 
in a system-wide slab cache and attaches it as a pointer to the new task structure.
Whenever a process attempts to operate on a namespaced resource, the kernel follows its reference to the 
proxy, and the resources' reference to the namespace. If the resource is managed by the same namespace 
that the process is a part of, then the respective operation is permitted.
Code snippet \ref{code:fundamentals/namespaces/process} shows an example of how clone is used 
within the runtime implementation. The namespaces are parsed from the configuration file and 
aggregated into a bit mask \verb|cc_ns_new|. The runtime then calls out to the \verb|clone3()| system call
with the namespace mask set, as well as a pointer to a pollable file descriptor for the 
container that should be populated by the kernel - \verb|cc_pollfd|. 

\begin{lstlisting}[style=c-code-snippets, label={code:implementation/namespaces/clone}, caption={Container instantiation within the runtime using clone3}]
static inline pid_t clone3(struct clone_args *args, size_t args_size)
{
    return (pid_t) syscall(SYS_clone3, args, args_size);
}

static int container_entrypoint(void *arg)
{
    struct conty_container *cc = (struct conty_container *) arg;
    /* Configure container within new namespace set */
    /* At the end, call execve to load the user-defined binary */
}

int conty_container_spawn(struct conty_container *cc)
{
    struct clone_args args = {
        // cc->cc_ns_new contains
        // CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWNET
        .flags = cc->cc_ns_new | CLONE_PIDFD;
        .pidfd = (__u64)(uintptr_t) &cc->cc_pollfd,
    };

    cc->cc_pid = clone3(&args, CLONE_ARGS_SIZE_VER2);
    if (cc->cc_pid == 0) 
        /* Within container */
        _exit(container_entrypoint(cc));
    else 
        /* Within runtime */
}
\end{lstlisting}

Spawning a process in a new set of namespaces is not enough to provide a secure runtime environment.
As a matter of fact, the container's runtime environment after \verb|clone()| is insecure and unusable.
The runtime must configure the environment depending on the namespaces that were created.  

If the runtime creates a container process with the \verb|CLONE_NEWUSER| flag set, i.e in a new user namespace,
the kernel initialises the container's security context to an unprivileged state by setting its 
user and group identifiers to the overflow value, also known as the \enquote{nobody} user.
This user has the least privileges on the system, making the new user namespace particularly unuseful. 
Even if the namespace manages security-sensitive resources, such as network devices and mount points,
the container process is considered unprivileged to access them. For this reason, the container runtime 
has the responsibility of remapping the invalid identifiers to valid user identifiers. 
It is particularly important to note that the remapped identifiers must refer to users within 
the root user namespace, i.e on the host. The remapping is done by writing a range of 
identifiers to the files \verb|/proc/[pid]/uid_map| and \verb|/proc/[pid]/gid_map| where \verb|pid|
refers to the process identifier of the container.
These files consist of multiple entries separated by newline characters. 
An entry is represented by three integers - $c$, $h$ and $a$. 
The kernel maps the half-open range of identifiers $[c, c+a)$ to $[h, h+a)$ where 
$c$ denotes the starting identifier in the container's user namepace and $h$ denotes 
the starting identifier in the root user namespace.
\begin{lstlisting}[label={code:implementation/namespaces/user-example}, style=bash, caption={Example of an identifier mapping}]
$ cat /proc/self/uid_map
0 1000 50
\end{lstlisting}
Consider the example in code snippet \ref{code:implementation/namespaces/user-example}. The 
runtime has mapped the root user in the container's user namespace to the user with identifier 1000 
on the host. Similarly, user 1 in the container is mapped to user 1001 on the host. The same logic 
applies to all users up to 49 and 1049 inside the container and on the host, respectively. 
If a malicious attacker gains access to a container and manages to break out of its user namespace, 
protecting the host system depends on the identifier mapping. In the example above, the 
attacker will still be unprivileged on the host, provided that users $(1000, 1049)$ are unprivileged.
If, however, the runtime writes a mapping
\begin{equation}
    c = h = 0;  a = 1, \label{eq:implementation/root-mapping}
\end{equation}
a container escape proves critical.
The mapping in (\ref{eq:implementation/root-mapping}) is the default one for containers created by the Docker engine, necessitating
additional configurations to enable rootless containers.
The identifier mappings of a container also have an impact on its noninterference boundary with 
other containers. If the runtime maps the same user identifer on the host to the root user inside the user namespace of two different containers, an 
attacker that escapes from one container will be able to enter the user namespace of the other. Upon entering,
the attacker will have root privileges. Therefore, for a truly secure environment, two invariants must hold - 
mapped identifier ranges must not overlap across different containers, and a privileged user on the host must 
not be mapped to a user inside a container. The kernel imposes several restrictions to user-space for 
writing to the map files. First, the kernel prohibits more than a single write to such a file. 
That is, the runtime can write only once to that file. Furthermore, at least one line must be 
written to the file. An attacker that subsequently attempts to manipulate the mappings would not 
be able to. Secondly, the writing process must have the \verb|CAP_SETUID| and 
\verb|CAP_SETGID| capabilities in the root user namespace, or otherwise it can 
write only a single entry into the file. Deciding which identifier mappings to write is a function 
of a container engine, not the runtime. The runtime simply reads the identifier mappings
from a configuration file like the one defined in code snippet \ref{code:oci-config.json}, buffers 
them in memory and dumps them to the respective map files from within the container process.
This is the very first thing that the container process does to ensure that subsequent operations
are properly authorised by the kernel. 

Creating a process with the \verb|CLONE_NEWNS| flag puts it in a new mount namespace that 
inherits a copy of the parent's mount points. This includes the parent's root mount (at \verb|/|),
which contains various \enquote{submounts} such as the pseudo filesystems \verb|/proc| and \verb|/sys|,
the POSIX message queue filesystem \verb|/dev/mqueue| and the POSIX shared-memory filesystem \verb|/dev/shm|.
The container runtime is responsible for setting up all of these filesystems inside the new mount namespace,
under the base directory of the container's dedicated root filesystem. Note that upon creation,
the container's root filesystem is a simple directory, not a mount point. 
The runtime must convert it into a mount point so that it can replace the inherited root mount 
with a new one. Therefore, the runtime bind mounts the aforementioned directory onto itself, using 
the \verb|mount| system call. Recall from Section \ref{sections:fundamentals/namespaces/mount} 
that every mount point is associated with a propagation type. If the parent mount of the 
directory that holds the root filesystem has a shared propagation type, then bind mounting 
that directory inside the container will propagate the mount event downstream to the parent mount, 
causing the bind mount to appear in the set of mount points in the root mount namespace, i.e on the host.
This is not desirable as it directly interferes with the host environment. For this reason, 
the container process first remounts the old root filesystem with a propagation type set to \verb|MS_PRIVATE|
so that any changes in the container's mount namespace are not propagated downstream. 
Note that setting the propagation type to \verb|MS_SLAVE| would also work, if the container 
wants to receive mount events from the host. This process is shown in code snippet \ref{code:implementation/namespaces/mount}.
The variable \verb|rfs->cro_dst| holds the absolute path to the container's root filesystem.

\begin{lstlisting}[style=c-code-snippets, label={code:implementation/namespaces/mount}, caption={Remounting the original root filesystem to disable mount propagation events and bind mounting the container's root filesystem onto itself.}]
/* Error handling deliberately left out */
mount("", "/", "", MS_PRIVATE | MS_REC, NULL);
mount(rfs->cro_dst, rfs->cro_dst, "bind", MS_BIND | MS_REC, NULL);
mount("", rfs->cro_dst, "", MS_PRIVATE, NULL);
\end{lstlisting}

\section{Benchmark}
\label{ch:implementation/benchmark}
\subsection{Network workload}
\subsection{Filesystem workload}
\subsection{Processing workload}
\subsection{Command-line interface}
